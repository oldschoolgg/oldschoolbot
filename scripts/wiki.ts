import { readFileSync, writeFileSync } from 'node:fs';

import '../src/lib/safeglobals';
import { type CombatAchievement, CombatAchievements } from '../src/lib/combat_achievements/combatAchievements';
import killableMonsters from '../src/lib/minions/data/killableMonsters';
import { quests } from '../src/lib/minions/data/quests';
import { sorts } from '../src/lib/sorts';
import { Bank, Monsters, itemNameFromID, toTitleCase } from '../src/lib/util';
import { Markdown, Tab, Tabs } from './markdown/markdown';

function combatAchievementHowToFinish(ca: CombatAchievement) {
	if ('rng' in ca) {
		return `1 in ${ca.rng.chancePerKill} chance per kill`;
	}
	if ('requirements' in ca) {
		return ca.requirements.requirements
			.map(req => ca.requirements.formatRequirement(req))
			.join(',')
			.replace('Kill Count Requirement: ', '')
			.replace('Minigame Requirements: ', '');
	}
	throw ca;
}

function handleMarkdownEmbed(identifier: string, filePath: string, contentToInject: string) {
	const contentToReplace = readFileSync(`./docs/src/content/docs/${filePath}`, 'utf8');
	const startMarker = `[[embed.${identifier}.start]]`;
	const endMarker = `[[embed.${identifier}.end]]`;
	const startIndex = contentToReplace.indexOf(startMarker);
	const endIndex = contentToReplace.indexOf(endMarker);

	if (startIndex === -1 || endIndex === -1) {
		console.error(`Markers (not found in the file. ${filePath} ${identifier}`);
		process.exit(1);
	}

	const newContent = `${contentToReplace.slice(0, startIndex + startMarker.length)}
{/* DO NOT EDIT - This section is auto-generated by the build script */}
${contentToInject}
{/* DO NOT EDIT - This section is auto-generated by the build script */}
${contentToReplace.slice(endIndex)}`;

	writeFileSync(`./docs/src/content/docs/${filePath}`, newContent, 'utf8');
}
async function renderCAMarkdown() {
	let markdown = '<Tabs>\n';
	for (const tier of Object.values(CombatAchievements)) {
		markdown += `<TabItem label="${tier.name}">
| Monster | Task Name | How To Unlock |
| -- | -- | -- |
`;
		for (const task of tier.tasks.sort((a, b) => a.monster.localeCompare(b.monster))) {
			markdown += `| ${task.monster} | ${task.name} | ${combatAchievementHowToFinish(task)} |\n`;
		}
		markdown += '</TabItem>\n';
	}
	markdown += '</Tabs>\n';
	handleMarkdownEmbed('ca_tasks', 'osb/combat-achievements.mdx', markdown);
}

function escapeItemName(str: string) {
	return str.replace(/\[/g, '\\[').replace(/\]/g, '\\]');
}

const name = (id: number) => escapeItemName(itemNameFromID(id)!);
async function renderMonstersMarkdown() {
	const markdown = new Markdown();

	for (const monster of killableMonsters
		.filter(m => m.equippedItemBoosts || m.itemInBankBoosts || m.itemCost)
		.filter(m => Monsters.get(m.id)!.data.combatLevel >= 80 && !m.name.includes('Revenant'))
		.sort((a, b) => a.name.localeCompare(b.name))) {
		const monstermd = new Markdown();
		monstermd.addLine(`## ${monster.name}`);

		const infoTab = new Tab().setTitle('Information').setContent(() => {
			const md = new Markdown();
			md.addLine(
				`- You can view the drops for this monster on the osrs wiki: [${monster.name}](https://oldschool.runescape.wiki/w/${encodeURIComponent(monster.name)})`
			);
			md.addLine(`- You can send your minion to kill this monster using: [[/k name:${monster.name}]]`);
			md.addLine(`- You can check your KC using: [[/minion kc name:${monster.name}]]`);
			md.addLine(`- You can check the KC leaderboard using: [[/lb kc monster\:${monster.name}]]`);
			md.addLine(`- You can check your collection log using: [[/cl name\\:${monster.name}]]`);
			md.addLine(`- You can check the collection log leaderboard using: [[/lb cl cl:${monster.name}]]`);

			if (monster.canBarrage) {
				md.addLine(`- You can barrage this monster [[/k name:${monster.name} method:barrage]]`);
			}
			if (monster.canCannon) {
				md.addLine(`- You can dwarf multicannon this monster [[/k name:${monster.name} method:cannon]]`);
			}
			if (monster.canChinning) {
				md.addLine(`- You can use chinchompas on this monster [[/k name:${monster.name} method:chinning]]`);
			}
			if (monster.slayerOnly) {
				md.addLine('- You can only kill this monster on a slayer task');
			}
			if (monster.existsInCatacombs) {
				md.addLine('- If on a slayer task, this monster can be killed in the catacombs');
			}
			if (monster.canBePked) {
				md.addLine(
					'- This monster is in the wilderness, and you can die to PKers when killing it. As such, you will always use your "wildy" gear setup when killing this monster.'
				);
			}

			return md.toString();
		});

		const costsTab = new Tab().setTitle('Costs').setContent(() => {
			const md = new Markdown();
			md.addLine(
				`- ${monster.healAmountNeeded ? `Requires food in your bank to kill, the amount needed is heavily reduced based on your gear/experience. ${monster.minimumHealAmount ? `You must have/use food that heals atleast ${monster.healAmountNeeded}HP` : ''}` : 'No Food Needed'}`
			);
			if (monster.itemCost) {
				md.addLine('**Item Cost**');
				for (const consumable of Array.isArray(monster.itemCost) ? monster.itemCost : [monster.itemCost]) {
					const allConsumables = [consumable, ...[consumable.alternativeConsumables ?? []]].flat();
					md.addLine(
						`- ${allConsumables.map(c => `${c.itemCost.itemIDs.map(id => `[[${name(id)}]]`).join(' ')}`).join(' or ')}`
					);
				}
			}

			if (monster.projectileUsage) {
				md.addLine('- Uses arrows/projectiles from your range gear');
			}

			return md.toString();
		});

		const requirementsTab = new Tab().setTitle('Requirements').setContent(() => {
			const requirementsMarkdown = new Markdown();

			if (monster.qpRequired) {
				requirementsMarkdown.addLine(`[[qp:${monster.qpRequired}]]`);
			}

			if (monster.levelRequirements) {
				requirementsMarkdown.addLine(
					Object.entries(monster.levelRequirements)
						.map(([skill, lvl]) => `[[${skill}:${lvl}]]`)
						.join(' ')
				);
			}

			if (monster.itemsRequired && monster.itemsRequired?.length > 0) {
				requirementsMarkdown.addLine('**Items Required**');
				for (const item of monster.itemsRequired) {
					if (Array.isArray(item)) {
						requirementsMarkdown.addLine(`- ${item.map(i => `[[${name(i)}]]`).join(' or ')}`);
					} else {
						requirementsMarkdown.addLine(`- [[${name(item)}]]`);
					}
				}
			}

			if (monster.requiredQuests) {
				requirementsMarkdown.addLine('**Required Quests**');
				for (const quest of monster.requiredQuests) {
					requirementsMarkdown.addLine(`- ${quests.find(q => q.id === quest)!.name}`);
				}
			}

			return requirementsMarkdown.toString();
		});

		const boostsTab = new Tab().setTitle('Boosts').setContent(() => {
			const boostsMarkdown = new Markdown();

			if (monster.itemInBankBoosts) {
				const bankBoosts = new Markdown();
				bankBoosts.setAccordion('Item in Bank Boosts');
				bankBoosts.addLine(
					'These boosts are applied from just being in your bank, and do not need to be equipped (but can also be equipped). The best boost you can use will automatically be used.'
				);
				for (const set of monster.itemInBankBoosts) {
					bankBoosts.addLine('You can have one of the following boosts:');
					for (const [item, boostPercent] of new Bank(set).items().sort(sorts.quantity)) {
						bankBoosts.addLine(`- ${boostPercent}% boost for [[${escapeItemName(item.name)}]]`);
					}
					bankBoosts.addLine('---');
				}
				boostsMarkdown.add(bankBoosts);
			}

			if (monster.equippedItemBoosts) {
				const bankBoosts = new Markdown();
				bankBoosts.setAccordion('Equipped Item Boosts');
				bankBoosts.addLine(
					'To get these boosts, you need the item equipped in the right setup. The best boost you can use will automatically be used.'
				);
				for (const set of monster.equippedItemBoosts) {
					bankBoosts.addLine(
						`${toTitleCase(set.gearSetup)} gear boosts${set.required ? ', it is **required** to have atleast one of these' : ''}:`
					);
					for (const item of set.items.sort((a, b) => b.boostPercent - a.boostPercent)) {
						bankBoosts.addLine(`- ${item.boostPercent}% boost for [[${name(item.itemID)}]]`);
					}
					bankBoosts.addLine('---');
				}
				boostsMarkdown.add(bankBoosts);
			}

			if (monster.degradeableItemUsage) {
				const bankBoosts = new Markdown();
				bankBoosts.setAccordion('Degradeable/Chargeable Item Boosts');
				bankBoosts.addLine('These boosts are for items which degrade or have charges.');
				for (const set of monster.degradeableItemUsage) {
					bankBoosts.addLine(
						`${toTitleCase(set.gearSetup)} gear boosts${set.required ? ', it is **required** to have atleast one of these' : ''}:`
					);
					for (const item of set.items.sort((a, b) => b.boostPercent - a.boostPercent)) {
						bankBoosts.addLine(`- ${item.boostPercent}% boost for [[${name(item.itemID)}]]`);
					}
					bankBoosts.addLine('---');
				}
				boostsMarkdown.add(bankBoosts);
			}

			if (monster.pohBoosts) {
				const pohBoosts = new Markdown();
				pohBoosts.setAccordion('POH Boosts');
				pohBoosts.addLine('These boosts are from having the right object built in your POH.');
				for (const [_pohSlot, boostGroup] of Object.entries(monster.pohBoosts).sort((a, b) =>
					a[0].localeCompare(b[0])
				)) {
					const mdSet = new Markdown();
					mdSet.addLine(`**${toTitleCase(_pohSlot)}**`);
					for (const [item, boostPercent] of Object.entries(boostGroup).sort((a, b) => b[1] - a[1])) {
						mdSet.addLine(`- ${boostPercent}% boost for ${item}`);
					}
					pohBoosts.add(mdSet);
				}
				pohBoosts.addLine('---');
				boostsMarkdown.add(pohBoosts);
			}

			return boostsMarkdown.toString();
		});
		const tabs = new Tabs([infoTab, costsTab, requirementsTab, boostsTab]);
		monstermd.add(tabs);
		monstermd.addLine('---');
		markdown.add(monstermd);
	}

	handleMarkdownEmbed('monsters', 'osb/monsters.mdx', markdown.toString());
}

async function wiki() {
	await Promise.all([renderCAMarkdown(), renderMonstersMarkdown()]);
}

wiki();
