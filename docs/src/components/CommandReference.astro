---
import { getEntry } from 'astro:content';
import CommandNodeTree from './CommandNodeTree.astro';

const commandsEntry = await getEntry('generated', 'commands');
if (!commandsEntry) {
	throw new Error('Missing generated commands data at docs/src/content/generated/commands.json');
}

const commandsDoc = commandsEntry.data;
const totalCommands = commandsDoc.commands.length;
const toAnchorId = (commandPath: string) =>
	commandPath
		.toLowerCase()
		.replace(/[^a-z0-9]+/g, '-')
		.replace(/(^-|-$)/g, '');
---

<section data-commands-root>
	<label for="command-filter"><strong>Search commands</strong></label>
	<div>
		<input
			id="command-filter"
			type="search"
			data-commands-filter
			placeholder="Search by command, path, description, or option..."
		/>
		<button type="button" data-commands-clear hidden>Clear</button>
	</div>
	<p data-commands-results aria-live="polite" hidden></p>
	<label for="command-jump"><strong>Jump to command</strong></label>
	<select id="command-jump" data-commands-jump>
		<option value="">Select a command...</option>
		{
			commandsDoc.commands.map(command => (
				<option value={toAnchorId(command.path)}>{`/${command.path}`}</option>
			))
		}
	</select>
	<p>This page is generated from slash command definitions.</p>
	<p><strong>Total top-level commands:</strong> {totalCommands}</p>
	<p><strong>Generated:</strong> {new Date(commandsDoc.generatedAt).toUTCString()}</p>

	{commandsDoc.commands.map(command => <CommandNodeTree node={command} level={2} />)}
</section>

<style is:global>
	[data-commands-root] [data-command-node] {
		margin: 1rem 0;
	}

	[data-commands-root] .command-card {
		border: 1px solid var(--sl-color-gray-5);
		border-radius: 0.75rem;
		padding: 1rem;
		background: color-mix(in srgb, var(--sl-color-bg) 88%, var(--sl-color-gray-6));
	}

	[data-commands-root] .command-card-top {
		border-left: 4px solid var(--sl-color-accent);
	}

	[data-commands-root] .command-card-sub {
		margin-left: 0.75rem;
		border-color: var(--sl-color-gray-6);
		background: color-mix(in srgb, var(--sl-color-bg) 92%, var(--sl-color-gray-7));
	}

	[data-commands-root] .command-header {
		display: flex;
		gap: 0.75rem;
		justify-content: space-between;
		align-items: flex-start;
	}

	[data-commands-root] .command-header-text {
		min-width: 0;
		flex: 1;
	}

	[data-commands-root] .command-header-text h2,
	[data-commands-root] .command-header-text h3,
	[data-commands-root] .command-header-text h4,
	[data-commands-root] .command-header-text h5,
	[data-commands-root] .command-header-text h6 {
		margin: 0;
	}

	[data-commands-root] .command-description {
		margin: 0.3rem 0 0;
		white-space: nowrap;
		overflow: hidden;
		text-overflow: ellipsis;
	}

	[data-commands-root] .command-header-meta {
		display: flex;
		flex-wrap: wrap;
		gap: 0.4rem;
		justify-content: flex-end;
		align-items: center;
	}

	[data-commands-root] .command-chip {
		font-size: 0.75rem;
		padding: 0.2rem 0.45rem;
		border-radius: 999px;
		border: 1px solid var(--sl-color-gray-5);
		background: color-mix(in srgb, var(--sl-color-bg) 82%, var(--sl-color-gray-6));
	}

	[data-commands-root] .command-toggle {
		font-size: 0.75rem;
		padding: 0.25rem 0.5rem;
	}

	[data-commands-root] [data-command-details] {
		margin-top: 0.9rem;
		padding-top: 0.8rem;
		border-top: 1px solid var(--sl-color-gray-6);
	}

	[data-commands-root] .command-options-table tbody tr:nth-child(even) {
		background: color-mix(in srgb, var(--sl-color-bg) 86%, var(--sl-color-gray-6));
	}
</style>

<script is:inline>
	(() => {
		const root = document.querySelector('[data-commands-root]');
		if (!root) return;

		const filterInput = root.querySelector('[data-commands-filter]');
		const clearButton = root.querySelector('[data-commands-clear]');
		const resultsLabel = root.querySelector('[data-commands-results]');
		const jumpSelect = root.querySelector('[data-commands-jump]');
		const nodeElements = Array.from(root.querySelectorAll('[data-command-node]'));

		if (!filterInput || !clearButton || !resultsLabel || !jumpSelect || nodeElements.length === 0) return;

		const manualExpandedPaths = new Set();
		const parentByNode = new Map();

		for (const node of nodeElements) {
			const parentNode = node.parentElement ? node.parentElement.closest('[data-command-node]') : null;
			parentByNode.set(node, parentNode);
		}

		const normalize = value => value.trim().toLowerCase();
		const getPath = node => (node.getAttribute('data-path') ?? '').toLowerCase();
		const getAnchorId = node => (node.getAttribute('data-anchor-id') ?? '').toLowerCase();
		const hasDetails = node => node.getAttribute('data-has-details') === 'true';

		const setExpandedState = (node, expanded, visible) => {
			const toggleButton = node.querySelector(':scope > .command-card > .command-header [data-command-toggle]');
			const detailsContainer = node.querySelector(':scope > .command-card > [data-command-details]');
			if (!toggleButton || !detailsContainer) return;

			toggleButton.hidden = !visible;
			toggleButton.setAttribute('aria-expanded', expanded ? 'true' : 'false');
			toggleButton.textContent = expanded ? 'Collapse' : 'Expand';
			detailsContainer.hidden = !expanded || !visible;
		};

		const applyFilter = () => {
			const filterText = normalize(filterInput.value);
			const hasFilter = filterText.length > 0;
			const visibleNodes = new Set();
			const autoExpandedNodes = new Set();
			let resultsCount = 0;

			if (hasFilter) {
				for (const node of nodeElements) {
					const searchText = (node.getAttribute('data-search-text') ?? '').toLowerCase();
					if (!searchText.includes(filterText)) continue;

					resultsCount += 1;
					visibleNodes.add(node);
					autoExpandedNodes.add(node);

					let currentNode = node;
					while (parentByNode.get(currentNode)) {
						const parentNode = parentByNode.get(currentNode);
						visibleNodes.add(parentNode);
						autoExpandedNodes.add(parentNode);
						currentNode = parentNode;
					}
				}
			}

			for (const node of nodeElements) {
				const visible = hasFilter ? visibleNodes.has(node) : true;
				node.hidden = !visible;

				if (!hasDetails(node)) continue;
				const nodePath = getPath(node);
				const manualExpanded = nodePath.length > 0 && manualExpandedPaths.has(nodePath);
				const autoExpanded = hasFilter && autoExpandedNodes.has(node);
				setExpandedState(node, manualExpanded || autoExpanded, visible);
			}

			if (!hasFilter) {
				resultsLabel.hidden = true;
				resultsLabel.textContent = '';
				clearButton.hidden = true;
				return;
			}

			resultsLabel.hidden = false;
			resultsLabel.textContent = `${resultsCount} result${resultsCount === 1 ? '' : 's'}`;
			clearButton.hidden = false;
		};

		const expandParentsForNode = targetNode => {
			const targetPath = getPath(targetNode);
			if (targetPath) {
				manualExpandedPaths.add(targetPath);
			}
			let currentNode = targetNode;
			while (parentByNode.get(currentNode)) {
				const parentNode = parentByNode.get(currentNode);
				const parentPath = getPath(parentNode);
				if (parentPath) {
					manualExpandedPaths.add(parentPath);
				}
				currentNode = parentNode;
			}
		};

		const expandParentsForHash = () => {
			const hashValue = decodeURIComponent(window.location.hash.replace(/^#/, '')).trim().toLowerCase();
			if (!hashValue) return;
			const targetNode = nodeElements.find(node => getAnchorId(node) === hashValue);
			if (!targetNode) return;

			expandParentsForNode(targetNode);
			applyFilter();
			const heading = document.getElementById(hashValue);
			if (heading) {
				heading.scrollIntoView({ block: 'start' });
			}
		};

		root.addEventListener('click', event => {
			const target = event.target;
			if (!(target instanceof Element)) return;
			const toggle = target.closest('[data-command-toggle]');
			if (!toggle) return;

			const parentNode = toggle.closest('[data-command-node]');
			if (!parentNode) return;
			const path = getPath(parentNode);
			if (!path) return;

			if (manualExpandedPaths.has(path)) {
				manualExpandedPaths.delete(path);
			} else {
				manualExpandedPaths.add(path);
			}
			applyFilter();
		});

		filterInput.addEventListener('input', applyFilter);
		jumpSelect.addEventListener('change', () => {
			const selectedAnchor = String(jumpSelect.value ?? '').trim().toLowerCase();
			if (!selectedAnchor) return;
			const targetNode = nodeElements.find(node => getAnchorId(node) === selectedAnchor);
			if (!targetNode) return;

			expandParentsForNode(targetNode);
			applyFilter();
			window.location.hash = selectedAnchor;
		});
		clearButton.addEventListener('click', () => {
			filterInput.value = '';
			applyFilter();
			filterInput.focus();
		});

		applyFilter();
		expandParentsForHash();
		window.addEventListener('hashchange', expandParentsForHash);
	})();
</script>
