diff --git a/src/mahoji/commands/tames.ts b/src/mahoji/commands/tames.ts
index 1234567..abcdef0 100644
--- a/src/mahoji/commands/tames.ts
+++ b/src/mahoji/commands/tames.ts
@@ ... @@
+// Helper for itemCost validation and removal for killCommand
+function hasRequiredItemCost(
+	userBank: Bank,
+	monster: TameKillableMonster,
+	quantity: number
+): { ok: boolean; error?: string; totalCost?: Bank } {
+	if (!monster.itemCost) return { ok: true };
+	const itemCost = Array.isArray(monster.itemCost) ? monster.itemCost[0] : monster.itemCost;
+	const qtyMultiplier = itemCost.qtyPerKill ?? 1;
+	const totalCost = itemCost.itemCost.clone().multiply(quantity * qtyMultiplier);
+	if (!userBank.has(totalCost)) {
+		return { ok: false, error: `You need ${totalCost} to kill ${quantity} ${monster.name}.`, totalCost };
+	}
+	return { ok: true, totalCost };
+}
@@ ... @@
-async function killCommand(user: MUser, channelID: string, str: string) {
+async function killCommand(user: MUser, channelID: string, str: string) {
 	const { tame, activity, species } = await getUsersTame(user);
 	if (!tame || !species) {
 		return 'You have no selected tame.';
 	}
 	if (species.type !== TameType.Combat) {
 		return 'This tame species cannot do PvM.';
 	}
 	if (activity) {
 		return `${tameName(tame)} is busy.`;
 	}
 	//
 	const monster = tameKillableMonsters.find(
 		i => stringMatches(i.name, str) || i.aliases.some(alias => stringMatches(alias, str))
 	);
 	if (monster?.tameCantKill) {
 		return 'Tames cannot kill this monster.';
 	}
 	if (!monster) return "That's not a valid monster.";
 	if (monster.mustBeAdult && tame.growth_stage !== tame_growth.adult) {
 		return 'Only fully grown tames can kill this monster.';
 	}
 	if (monster.requiredBitfield && !user.bitfield.includes(monster.requiredBitfield)) {
 		return "You haven't unlocked this monster.";
 	}
 	// Get the amount stronger than minimum, and set boost accordingly:
 	const [speciesMinCombat, speciesMaxCombat] = species.combatLevelRange;
 	// Example: If combat level is 80/100 with 70 min, give a 10% boost.
 	const combatLevelBoost = calcWhatPercent(tame.max_combat_level - speciesMinCombat, speciesMaxCombat);

 	// Increase trip length based on minion growth:
 	let speed = monster.timeToFinish * tameGrowthLevel(tame);

 	const boosts = [];

 	// Apply calculated boost:
 	const combatLevelChange = reduceNumByPercent(speed, combatLevelBoost);
 	boosts.push(
 		`${combatLevelBoost}% (${formatDuration(
 			calcPercentOfNum(combatLevelBoost, speed),
 			true
 		)}) speed boost for combat level`
 	);
 	speed = combatLevelChange;

 	let maxTripLength = Time.Minute * 20 * (4 - tameGrowthLevel(tame));
 	if (tameHasBeenFed(tame, itemID('Zak'))) {
 		maxTripLength += Time.Minute * 35;
 		boosts.push('+35mins trip length (ate a Zak)');
 	}

 	const patronBoost = patronMaxTripBonus(user) * 2;
 	if (patronBoost > 0) {
 		maxTripLength += patronBoost;
 		boosts.push(`+${formatDuration(patronBoost, true)} trip length for T${getUsersPerkTier(user) - 1} patron`);
 	}

 	if (isWeekend()) {
 		speed = reduceNumByPercent(speed, 10);
 		boosts.push('10% weekend boost');
 	}
 	if (tameHasBeenFed(tame, itemID('Dwarven warhammer'))) {
 		speed = reduceNumByPercent(speed, 30);
 		boosts.push('30% faster (ate a DWWH)');
 	}

 	for (const { item, boost } of igneClaws) {
 		if (tame.equipped_primary === item.id) {
 			boosts.push(`${boost}% faster (${item.name})`);
 			speed = reduceNumByPercent(speed, boost);
 			break;
 		}
 	}

 	if (monster.minArmorTier) {
 		const theirArmor = tame.equipped_armor ? igneArmors.find(i => i.item.id === tame.equipped_armor)! : null;
 		if (
 			!theirArmor ||
 			igneArmors.indexOf(theirArmor) < igneArmors.indexOf(igneArmors.find(i => i.item === monster.minArmorTier)!)
 		) {
 			return `You need ${monster.minArmorTier.name} on your tame, or better, to kill ${monster.name}.`;
 		}
 	}

 	// Calculate monster quantity:
 	const quantity = Math.floor(maxTripLength / speed);
 	if (quantity < 1) {
 		return "Your tame can't kill this monster fast enough.";
 	}
-
-	const foodRes = await removeRawFood({
-		totalHealingNeeded: (monster.healAmountNeeded ?? 1) * quantity,
-		healPerAction: monster.healAmountNeeded ?? 1,
-		user,
-		monster,
-		quantity,
-		tame,
-		timeToFinish: speed,
-		maxTripLength
-	});
-	if (!foodRes.success) {
-		return foodRes.str;
-	}
-
-	const fakeDuration = Math.floor(quantity * speed);
-
-	await trackLoot({
-		id: monster.name,
-		changeType: 'cost',
-		type: 'Monster',
-		totalCost: foodRes.removed,
-		suffix: 'tame',
-		users: [
-			{
-				id: user.id,
-				cost: foodRes.removed
-			}
-		]
-	});
-
-	const kcs = await getIgneTameKC(tame);
-	const deathChance = monster.deathChance ? monster.deathChance({ tame, kc: kcs.idBank[monster.id] ?? 0 }) : 0;
-	let realDuration: number = fakeDuration;
-	let deaths = 0;
-	for (let i = 0; i < quantity; i++) {
-		if (percentChance(deathChance)) {
-			deaths++;
-			realDuration -= calcPercentOfNum(randInt(30, 60), speed);
-		}
-	}
-
-	await createTameTask({
-		user,
-		channelID: channelID.toString(),
-		selectedTame: tame,
-		data: {
-			type: TameType.Combat,
-			monsterID: monster.id,
-			quantity
-		},
-		type: TameType.Combat,
-		duration: realDuration,
-		fakeDuration: deaths > 0 ? fakeDuration : undefined,
-		deaths
-	});
-
-	let reply = `${tameName(tame)} is now killing ${quantity}x ${monster.name}${
-		deathChance > 0 ? `, and has a ${deathChance.toFixed(2)}% chance of dying` : ''
-	}. The trip will take ${formatDuration(fakeDuration)}.\n\nRemoved ${foodRes.str}`;
-
-	if (boosts.length > 0) {
-		reply += `\n\n**Boosts:** ${boosts.join(', ')}.`;
-	}
-
-	reply += `\n\n${monster.name} has a base kill time of **${formatDuration(
-		monster.timeToFinish,
-		true
-	)}**, your kill time is **${formatDuration(speed, true)}**, meaning you can kill **${(maxTripLength / speed).toFixed(2)}** in your max trip length of **${formatDuration(maxTripLength, true)}**`;
-
-	return reply;
-}
+	// --- Item cost check (NEW) ---
+	const costResult = hasRequiredItemCost(user.bank, monster, quantity);
+	if (!costResult.ok) {
+		return costResult.error;
+	}
+	// Remove item cost if required
+	if (costResult.totalCost && costResult.totalCost.length > 0) {
+		await user.removeItemsFromBank(costResult.totalCost);
+		await prisma.tame.update({
+			where: { id: tame.id },
+			data: {
+				total_cost: new Bank(tame.total_cost as ItemBank).add(costResult.totalCost).toJSON()
+			}
+		});
+		updateBankSetting('economyStats_PVMCost', costResult.totalCost);
+	}
+
+	const foodRes = await removeRawFood({
+		totalHealingNeeded: (monster.healAmountNeeded ?? 1) * quantity,
+		healPerAction: monster.healAmountNeeded ?? 1,
+		user,
+		monster,
+		quantity,
+		tame,
+		timeToFinish: speed,
+		maxTripLength
+	});
+	if (!foodRes.success) {
+		return foodRes.str;
+	}
+
+	const fakeDuration = Math.floor(quantity * speed);
+
+	await trackLoot({
+		id: monster.name,
+		changeType: 'cost',
+		type: 'Monster',
+		totalCost: foodRes.removed,
+		suffix: 'tame',
+		users: [
+			{
+				id: user.id,
+				cost: foodRes.removed
+			}
+		]
+	});
+
+	const kcs = await getIgneTameKC(tame);
+	const deathChance = monster.deathChance ? monster.deathChance({ tame, kc: kcs.idBank[monster.id] ?? 0 }) : 0;
+	let realDuration: number = fakeDuration;
+	let deaths = 0;
+	for (let i = 0; i < quantity; i++) {
+		if (percentChance(deathChance)) {
+			deaths++;
+			realDuration -= calcPercentOfNum(randInt(30, 60), speed);
+		}
+	}
+
+	await createTameTask({
+		user,
+		channelID: channelID.toString(),
+		selectedTame: tame,
+		data: {
+			type: TameType.Combat,
+			monsterID: monster.id,
+			quantity
+		},
+		type: TameType.Combat,
+		duration: realDuration,
+		fakeDuration: deaths > 0 ? fakeDuration : undefined,
+		deaths
+	});
+
+	let reply = `${tameName(tame)} is now killing ${quantity}x ${monster.name}${
+		deathChance > 0 ? `, and has a ${deathChance.toFixed(2)}% chance of dying` : ''
+	}. The trip will take ${formatDuration(fakeDuration)}.\n\nRemoved ${foodRes.str}`;
+
+	if (costResult.totalCost && costResult.totalCost.length > 0) {
+		reply += `\n\nRemoved required items: ${costResult.totalCost}.`;
+	}
+
+	if (boosts.length > 0) {
+		reply += `\n\n**Boosts:** ${boosts.join(', ')}.`;
+	}
+
+	reply += `\n\n${monster.name} has a base kill time of **${formatDuration(
+		monster.timeToFinish,
+		true
+	)}**, your kill time is **${formatDuration(speed, true)}**, meaning you can kill **${(maxTripLength / speed).toFixed(2)}** in your max trip length of **${formatDuration(maxTripLength, true)}**`;
+
+	return reply;
+}
@@ ... @@